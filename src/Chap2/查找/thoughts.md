**求旋转数组的最小数**

这道题本可以用暴力方法解决，顺序查找即可，O(n)的时间复杂度也不高。

但是，题目给出了一些特定条件：是排序数组的旋转数组，即前后两部分是有序的。

***

这样就有了优化的解法：二分查找

但是不是所有的输入情况都可以用二分查找，分成三种情况。

```java
 /*
    * 题目为啥要提出旋转数组这个概念，我们可以如何利用它？能有更好的解法吗？
    *   旋转数组是有序数组的变形，特点是前面一部分有序，后面一部分也有序。且前面一部分都比后面一部分要大。
    *   可以发现最小元素在前一部分的最大值之后，且后一部分的第一数字。
    *
    * 解题思路：
    *   结合旋转数组的特点，定义头尾两个指针。然后缩小这个区间就能找到最小值
    *   缩小规则：取中间值，若中间值 大于 头指针处的值，头向中间缩进；若中间值 小于 尾指针处的值，尾向中间缩进。
    *
    *   即：中间大于头，头换到中间。中间小于尾，尾换到中间。区间长度为2时，第二个数就是最小的
    *
    * 补充：
    *   1、旋转数组是是排序数组自身，即没有发生旋转。
    *       尾不再小于头了，判断尾大于头，数组返回arr[head]
    *
    *   2、旋转数组的头、尾、中间 都相同。
    *       二分法失效，采用顺序查找
    *
    * 实例分析：
    *    旋转数组：{3,4,5,1,2}
    *    1、头3，尾2，中5  （中间大于头）
    *    2、头5，尾2，中1  （中间小于尾）
    *    3、头5，尾1      （区间长度为2,结束）
    *
    * 提升一下：
    *   二分查找的本质是减少查找次数，将查找区间不断缩小，不要局限于只能是对半缩小这种情况。
    * */
    public static int findMinInArray1(int[] arr) {

         int head = 0;
         int tail = arr.length-1;
         /**<h2>旋转数组是本身</h2>*/
         if (arr[head] < arr[tail])
             return arr[head];

         int mid = (head+tail)/2;

         //二分法失效，只能顺序查找
         if (arr[mid]== arr[head] && arr[mid] == arr[tail])
             return findMinInArray(arr);
         else {  //可以用二分法查找
             while ((tail - head) > 2) {
                 if (arr[mid] > arr[tail]){ //中间大于头
                     head = mid;
                     mid = (head+tail)/2;
                 }
                 if (arr[mid] < arr[tail]){ //中间小于尾
                     tail = mid;
                     mid = (head+tail)/2;
                 }
             }
             return arr[tail];
         }
    }
```

**人生也要在努力的路上寻求有化解**